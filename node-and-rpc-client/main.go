// block-rpc is Json client f√ºr a btcd rpc server
package main

import (
	"io/ioutil"
	"log"
	"path/filepath"
	"time"

	"github.com/btcsuite/btcd/chaincfg/chainhash"
	"github.com/btcsuite/btcd/rpcclient"
	"github.com/btcsuite/btcutil"
	"github.com/zew/blockchain-block-rpc-client/db"
	"github.com/zew/blockchain-block-rpc-client/jsonclient"
)

var client2 *jsonclient.Client

func init() {
	log.SetFlags(log.Lshortfile)
}

func init() {
	var err error
	// jsonclient.API_ROOT = "http://localhost:8334"
	client2, err = jsonclient.New()
	if err != nil {
		log.Fatalf("json webservice client creation failed: %v", err)
	}
}

func main() {

	// dbmap := db.InitDb("localhost", "3306", "blockchain_bitcoin", "blockchain_bitcoin", "blockchain_bitcoin", map[string]string{})
	dbmap := db.InitDb("10.1.132.25", "3306", "blockchain_bitcoin", "blockchain_bitcoin", "blockchain_bitcoin", map[string]string{})

	defer dbmap.Db.Close()
	dbmap.AddTableWithName(Tx{}, "tx").SetKeys(true, "id")
	err := dbmap.CreateTablesIfNotExists()
	if err != nil {
		log.Fatalf("Create tx table failed: %v", err)
	}
	// err := dbmap.TruncateTables()
	// if err != nil {
	// 	log.Fatalf("TruncateTables failed: %v", err)
	// }

	// Load the certificate for the TLS connection which is automatically
	// generated by btcd when it starts the RPC server and doesn't already
	// have one.
	btcdHomeDir := btcutil.AppDataDir("btcd", false)
	certs, err := ioutil.ReadFile(filepath.Join(btcdHomeDir, "rpc.cert"))
	if err != nil {
		log.Print(err)
		certs, err = ioutil.ReadFile(filepath.Join(".", "rpc.cert")) // try loading from app dir
		if err != nil {
			log.Fatal(err)
		}
	}

	// Create a new RPC client using websockets.  Since this example is
	// not long-lived, the connection will be closed as soon as the program
	// exits.
	connCfg := &rpcclient.ConnConfig{
		Host:     "10.1.132.25:8334",
		Endpoint: "ws",
		User:     "NVQGQaJ9FqHftrlxmmFsGR0YDVI=",
		Pass:     "ZHSs6q0n/LFyIshPmxo03cZFUiE=",
		// User:         "yourrpcuser",
		// Pass:         "yourrpcpass",
		Certificates: certs,
	}
	client, err := rpcclient.New(connCfg, nil)
	if err != nil {
		log.Fatal(err)
	}
	defer client.Shutdown()

	// Query the RPC server for the genesis block using the "getblock"
	// command with the verbose flag set to true and the verboseTx flag
	// set to false.
	genesisHashStr := "000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f"
	genesisHashStr = "00000000002b8cd0faa58444df3ba2a22af2b5838c7e4a5b687444f913a575c2" // has block 70.000
	genesisHashStr = "0000000000000e07595fca57b37fea8522e95e0f6891779cfd34d7e537524471" // has block 50.000

	nextHash := genesisHashStr
	for i := 0; i < 200*1000; i++ {

		blockHash, err := chainhash.NewHashFromStr(nextHash)
		if err != nil {
			log.Fatal(err)
		}
		block, err := client.GetBlockVerbose(blockHash)
		if err != nil {
			log.Fatal(err)
		}
		nextHash = block.NextHash

		// if i%5000 != 0 || i < 50000 {
		// 	continue
		// }
		if i%5000 != 0 {
			continue
		}
		// Display some details about the returned block.
		log.Printf("Hash:       %v (%v)\n", block.Hash, i)
		log.Printf("Prev Block: %v\n", block.PreviousHash)
		log.Printf("Next Block: %v\n", block.NextHash)
		// log.Printf("Merkle root: %v\n", block.MerkleRoot)
		log.Printf("Timestamp:  %v    Confirmations: %v\n", time.Unix(block.Time, 0).UTC().Format(time.RFC3339), block.Confirmations)
		log.Printf("Difficulty: %10.2f  Size %8v   Num Tx %4v\n", block.Difficulty, block.Size, len(block.Tx))

		for idx, txStr := range block.Tx {
			if idx%10 != 0 && idx > 5 {
				continue
			}
			log.Printf("\t\ttx %3v  %#v\n", idx, txStr)
			chainHash, err := chainhash.NewHashFromStr(txStr)
			if err != nil {
				log.Fatalf("conversion to chainhash failed: %V", err)
			}

			if false {
				tx, err := client.GetRawTransaction(chainHash)
				if err != nil {
					log.Fatalf("get RAW transaction data failed: %v", err)
				}
				// log.Printf("\t\t\t %#v\n", util.IndentedDump(tx))

				// this yields:
				// This implementation does not implement wallet commands
				log.Printf("\t\t\t %#v\n", tx.MsgTx())
				tx1, err := client.GetTransaction(chainHash)
				if err != nil {
					log.Fatalf("get  transaction data failed: %v", err)
				}
				log.Printf("\t\t\t %#v\n", tx1)
			}

			txJson, err := client2.GetTransaction(txStr)
			if err != nil {
				log.Fatalf("get  transaction from json webservice failed: %v", err)
			}
			// log.Printf("\t\t\t %#v\n", txJson)
			// log.Printf("%v", util.IndentedDump(txJson))
			PrintTx(txJson)

			b1 := FromBlockAndTx(block, txJson)
			err = dbmap.Insert(b1)
			if err != nil {
				log.Fatalf("Tx insertion error: %v \n%v", err, txJson)
			}

		}

		log.Printf("\n")
	}
	log.Printf("Regular finish\n")
}

func PrintTx(tx *jsonclient.Transaction) {

	if tx == nil {
		return
	}

	for _, inp := range tx.Inputs {
		if inp.PrevOut == nil {
			continue
		}
		log.Printf("\t\tInput  %3v  %12.2v - spent: %v - Seq %v",
			inp.PrevOut.N,
			inp.PrevOut.Value,
			inp.PrevOut.Spent,
			inp.Sequence,
		)
	}
	for j := range tx.Out {

		if false {
			a, err := client2.GetAddress(tx.Out[j].Addr)
			if err != nil {
				log.Fatalf("get  address from json webservice failed: %v", err)
			}
			if a.TotalReceived != a.TotalSent {
				if a.TotalReceived != a.TotalSent+a.FinalBalance {
					log.Fatalf("in-out inconsistency!")
				}
				log.Printf("\t\tAddress:    %12.2v %12.2v %12.2v", a.TotalReceived, a.TotalSent, a.FinalBalance)
			}
		}

		log.Printf("\t\tOutput %3v  %12.2v - spent: %v",
			tx.Out[j].N,
			tx.Out[j].Value,
			tx.Out[j].Spent,
		)
	}

	// t := time.Unix(int64(tx.LockTime), int64(0))
	// log.Printf("\t%v  \n", t.Format(time.RFC3339Nano)[:16])

}
